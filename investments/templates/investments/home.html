<!DOCTYPE html>
<html>
<head>
  <title>Dashboard Portafolios</title>
  <meta charset="utf-8" />
  <!-- Flatpickr CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <style>
    body {
      margin: 0; padding: 0; font-family: 'Segoe UI', Arial, sans-serif;
      background: #e8eaf6;
    }
    .section {
      min-height: 70vh;
      padding: 40px 0 30px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .section-azul {
      background: #1a237e;
      color: #fff;
    }
    .section-clara {
      background: #f5f5f5;
      color: #1a237e;
    }
    h1, h2 {
      margin-top: 0;
      font-weight: 600;
    }
    h1 { font-size: 2.7em; letter-spacing: -1px; }
    h2 { font-size: 2em; margin-bottom: 12px; }

    .tabla-portafolios table,
    .tabla-portafolios th,
    .tabla-portafolios td {
      border: 1px solid #b3b3cc;
      border-collapse: collapse;
      padding: 8px 12px;
    }
    .section-azul table,
    .section-azul th,
    .section-azul td {
      color: #fff;
      background: #243080;
    }
    .section-azul th {
      background: #2a368c;
    }
    .tabla-portafolios table {
      margin-top: 12px; margin-bottom: 8px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(30,30,70,0.06);
    }
    .input-row {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 7px;
    }
    .ver-btn {
      background: #3949ab;
      color: #fff;
      border: none;
      padding: 7px 18px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    .ver-btn:hover {
      background: #263174;
    }

    .chart-container {
      width: 100%;
      max-width: 900px;
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: flex-end;
      margin-bottom: 8px;
    }
    .small-label {
      font-size: 0.9em;
      margin-right: 4px;
    }
    #error-timeseries {
      color: #b00020;
      margin-top: 8px;
    }
    @media (max-width: 700px) {
      .section { padding: 20px 0; }
      h1 { font-size: 2em; }
      h2 { font-size: 1.3em; }
      .tabla-portafolios table, .tabla-portafolios th, .tabla-portafolios td {
        font-size: 0.95em;
        padding: 4px 5px;
      }
      .controls { flex-direction: column; align-items: flex-start; }
    }
  </style>

  <!-- Chart.js + flatpickr desde CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
</head>
<body>
  <!-- Sección 1: Portafolios (azul oscuro) -->
  <div class="section section-azul" id="pregunta-1">
    <h1>Pregunta 1</h1>
    <h2>Consulta el valor en USD por activo y portafolio para una fecha dada</h2>
    <div class="tabla-portafolios">
      <ul style="list-style: none; padding-left: 0;">
        {% for portfolio in portfolios %}
          <li>
            <div class="input-row">
              <strong>{{ portfolio.name }}</strong>
              <span>Fecha:</span>
              <input type="date" id="date-{{ portfolio.id }}" value="2022-02-15">
              <button class="ver-btn" onclick="consultarAPI('{{ portfolio.name|escapejs }}', '{{ portfolio.id }}')">
                Ver valores
              </button>
            </div>
            <div class="valores" id="valores-{{ portfolio.id }}"></div>
          </li>
        {% endfor %}
      </ul>
    </div>
  </div>

  <!-- Sección 2: Evolución temporal -->
  <div class="section section-clara" id="pregunta-2">
    <h2>Pregunta 2: Evolución temporal de \( w_{i,t} \) y \( V_t \)</h2>
    <p style="max-width: 600px;">
      Aquí puedes comparar la evolución de los pesos relativos \( w_{i,t} \) (stacked area con gradiente) y el valor total del portafolio \( V_t \) (línea) entre dos fechas existentes.
    </p>

    <div class="controls">
      <div>
        <div class="small-label">Portafolio:</div>
        <select id="portfolio-select">
          {% for portfolio in portfolios %}
            <option value="{{ portfolio.name|escapejs }}">{{ portfolio.name }}</option>
          {% endfor %}
        </select>
      </div>
      <div>
        <div class="small-label">Fecha inicio:</div>
        <input id="fecha-inicio" placeholder="YYYY-MM-DD" readonly style="cursor:pointer;">
      </div>
      <div>
        <div class="small-label">Fecha fin:</div>
        <input id="fecha-fin" placeholder="YYYY-MM-DD" readonly style="cursor:pointer;">
      </div>
      <div>
        <button class="ver-btn" onclick="fetchTimeSeries()">Ver evolución</button>
      </div>
    </div>

    <div class="chart-container">
      <div>
        <h3 style="margin-bottom:4px;">Pesos relativos \( w_{i,t} \) (stacked area)</h3>
        <canvas id="weights-chart" height="120"></canvas>
      </div>
      <div>
        <h3 style="margin-bottom:4px;">Valor total \( V_t \) (línea)</h3>
        <canvas id="value-chart" height="80"></canvas>
      </div>
    </div>

    <div id="error-timeseries"></div>
  </div>

  <script>
  let availableDates = [];
  let availableDatesSet = new Set();
  let fpStart = null;
  let fpEnd = null;

  async function initDateSlicer() {
    try {
      const resp = await fetch("/api/available_dates/");
      if (!resp.ok) throw new Error("No se pudo obtener las fechas disponibles.");
      const { available } = await resp.json();

      availableDates = available; // array de strings YYYY-MM-DD
      availableDatesSet = new Set(availableDates);

      // inicializar flatpickr con enable = lista exacta
      fpStart = flatpickr("#fecha-inicio", {
        dateFormat: "Y-m-d",
        enable: availableDates,
        defaultDate: availableDates[0],
        onChange: validateRange,
        maxDate: availableDates[availableDates.length - 1],
        minDate: availableDates[0]
      });
      fpEnd = flatpickr("#fecha-fin", {
        dateFormat: "Y-m-d",
        enable: availableDates,
        defaultDate: availableDates[availableDates.length - 1],
        onChange: validateRange,
        maxDate: availableDates[availableDates.length - 1],
        minDate: availableDates[0]
      });
    } catch (e) {
      console.error("initDateSlicer error:", e);
      document.getElementById("error-timeseries").textContent = "No se pudieron cargar las fechas disponibles.";
    }
  }

  function validateRange(selectedDates, dateStr, instance) {
    const start = document.getElementById("fecha-inicio").value;
    const end = document.getElementById("fecha-fin").value;
    if (start && end && start > end) {
      document.getElementById("error-timeseries").textContent = "fecha_inicio no puede ser posterior a fecha_fin.";
    } else {
      document.getElementById("error-timeseries").textContent = "";
    }
  }

  function consultarAPI(portfolioName, portfolioId) {
    const dateInput = document.getElementById(`date-${portfolioId}`);
    const fecha = dateInput.value;
    fetch(`/api/portfolio_usd_values/?portfolio=${encodeURIComponent(portfolioName)}&date=${fecha}`)
      .then(resp => resp.json())
      .then(data => {
        const div = document.getElementById(`valores-${portfolioId}`);
        if (!Array.isArray(data) || data.length === 0) {
          div.innerHTML = '<em>No hay datos disponibles para la fecha seleccionada.</em>';
          return;
        }
        let tabla = `
          <table>
            <tr>
              <th>Activo</th>
              <th>Cantidad</th>
              <th>Precio</th>
              <th>USD</th>
            </tr>
        `;
        data.forEach(row => {
          tabla += `<tr>
            <td>${row.asset}</td>
            <td>${parseFloat(row.quantity || 0).toLocaleString('en-US', { maximumFractionDigits: 4 })}</td>
            <td>${row.price !== null ? row.price.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 }) : ''}</td>
            <td>${row.usd_amount !== null ? row.usd_amount.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 }) : ''}</td>
          </tr>`;
        });
        const total = data.reduce((acc, row) => acc + (row.usd_amount || 0), 0);
        tabla += `</table>
        <div style="margin-top:4px;">
          <strong>Total portafolio:</strong>
          ${total.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 })}
        </div>`;
        div.innerHTML = tabla;
      })
      .catch(() => {
        const div = document.getElementById(`valores-${portfolioId}`);
        div.innerHTML = '<em>Error consultando el API.</em>';
      });
  }

  function colorFromInitialWeight(initialWeight, baseHue) {
    const lightness = 70 - (initialWeight * 40);
    return `hsl(${baseHue}, 60%, ${lightness}%)`;
  }

  async function fetchTimeSeries() {
    const portfolioName = document.getElementById("portfolio-select").value;
    const fechaInicio = document.getElementById("fecha-inicio").value;
    const fechaFin = document.getElementById("fecha-fin").value;
    const errorDiv = document.getElementById("error-timeseries");
    errorDiv.textContent = "";

    if (!portfolioName || !fechaInicio || !fechaFin) {
      errorDiv.textContent = "Todos los campos son requeridos.";
      return;
    }
    if (!availableDatesSet.has(fechaInicio) || !availableDatesSet.has(fechaFin)) {
      errorDiv.textContent = "Fecha inválida: selecciona una de las existentes.";
      return;
    }
    if (fechaInicio > fechaFin) {
      errorDiv.textContent = "fecha_inicio no puede ser posterior a fecha_fin.";
      return;
    }

    try {
      const resp = await fetch(`/api/portfolio_time_series/?portfolio=${encodeURIComponent(portfolioName)}&fecha_inicio=${fechaInicio}&fecha_fin=${fechaFin}`);
      const data = await resp.json();
      if (!Array.isArray(data) || data.length === 0) {
        errorDiv.textContent = "No hay datos para el rango seleccionado.";
        return;
      }

      const dates = data.map(d => d.date);
      const assetNames = Array.from(new Set(data.flatMap(d => d.assets.map(a => a.asset))));
      const wSeriesByAsset = {};
      assetNames.forEach(name => wSeriesByAsset[name] = []);
      const Vt = [];

      data.forEach(point => {
        Vt.push(point.V_t);
        const assetsMap = {};
        point.assets.forEach(a => {
          assetsMap[a.asset] = a.w_it !== null ? a.w_it : 0;
        });
        assetNames.forEach(name => {
          wSeriesByAsset[name].push(assetsMap[name] ?? 0);
        });
      });

      const initialWeights = {};
      if (data.length > 0) {
        const first = data[0];
        first.assets.forEach(a => {
          initialWeights[a.asset] = a.w_it ?? 0;
        });
      }

      // stacked area con gradiente
      const weightsCtx = document.getElementById("weights-chart").getContext("2d");
      if (window.weightsChart) window.weightsChart.destroy();

      const weightDatasets = assetNames.map((name, idx) => {
        const baseHue = (idx * 360 / assetNames.length) % 360;
        const initialWeight = initialWeights[name] ?? 0;

        const gradient = weightsCtx.createLinearGradient(0, 0, 0, 120);
        const darker = colorFromInitialWeight(initialWeight, baseHue);
        const lighter = `hsl(${baseHue}, 60%, 85%)`;
        gradient.addColorStop(0, darker);
        gradient.addColorStop(1, lighter);

        return {
          label: name,
          data: wSeriesByAsset[name],
          fill: idx === 0 ? "origin" : "-1",
          tension: 0.4,
          borderWidth: 1,
          spanGaps: true,
          backgroundColor: gradient,
          borderColor: `hsl(${baseHue}, 60%, 40%)`,
          pointRadius: 0
        };
      });

      window.weightsChart = new Chart(weightsCtx, {
        type: "line",
        data: {
          labels: dates,
          datasets: weightDatasets
        },
        options: {
          interaction: { mode: "index", intersect: false },
          plugins: {
            tooltip: {
              callbacks: {
                label: ctx => {
                  const val = ctx.parsed.y;
                  return `${ctx.dataset.label}: ${(val * 100).toFixed(2)}%`;
                }
              }
            },
            legend: { position: "bottom" }
          },
          scales: {
            y: {
              stacked: true,
              ticks: {
                callback: v => `${(v * 100).toFixed(0)}%`
              },
              title: { display: true, text: "Peso relativo" }
            },
            x: {
              title: { display: true, text: "Fecha" }
            }
          }
        }
      });

      // V_t
      const valueCtx = document.getElementById("value-chart").getContext("2d");
      if (window.valueChart) window.valueChart.destroy();
      window.valueChart = new Chart(valueCtx, {
        type: "line",
        data: {
          labels: dates,
          datasets: [{
            label: "V_t (USD)",
            data: Vt,
            borderWidth: 2,
            fill: false,
            tension: 0.2,
            pointRadius: 0
          }]
        },
        options: {
          interaction: { mode: "index", intersect: false },
          plugins: {
            tooltip: {
              callbacks: {
                label: ctx => {
                  const val = ctx.parsed.y;
                  return `V_t: ${Number(val).toLocaleString("en-US", { style: 'currency', currency: 'USD', maximumFractionDigits: 2 })}`;
                }
              }
            },
            legend: { display: false }
          },
          scales: {
            y: {
              title: { display: true, text: "Valor total (USD)" },
              ticks: {
                callback: v => {
                  return Number(v).toLocaleString("en-US", { style: 'currency', currency: 'USD', maximumFractionDigits: 0 });
                }
              }
            },
            x: {
              title: { display: true, text: "Fecha" }
            }
          }
        }
      });
    } catch (e) {
      console.error(e);
      errorDiv.textContent = "Error al consultar la serie temporal.";
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    initDateSlicer();
  });
  </script>
</body>
</html>
